Implementation Plan: Multi-Sheet Excel Processing + Dynamic Header Detection (v2)
Goal
what we have done (current code status; Excel processing runs from excel-processor-local/, legacy src/ worker is not updated):
Enhanced Alert System + Monthly AR Auto-Creation
Date Logic

✅ Excel date treated as billing reference (not due date) DONE (local processor)

✅ due_date = excel_date + 1 month DONE (local processor)

✅ invoice_date = now() when AR created from Excel DONE (local processor)

Alert Schedule

✅ Pre-alert: 3 days before due date DONE

✅ Due date alert: on due date DONE

✅ Overdue warning: single alert at exactly 7 days overdue DONE

✅ Escalation: customer + manager alerts (4–7 days overdue range) DONE

Status Auto-Update

✅ STATUS_CHANGED event emitted (PENDING → OVERDUE) DONE

✅ DateCheckerWorker exists (cron daily 9AM) DONE

Monthly AR Auto-Creation

✅ When AR marked PAID → auto-create next month AR DONE

✅ New AR due_date = old due_date + 1 month DONE

✅ New AR invoice_date = payment date DONE

✅ Auto-create future ARs up to 6 months ahead (regardless of payment) DONE

Multi-Sheet Excel Processing + Dynamic Header Detection
Core parsing

✅ Process all sheets (not just first) DONE (local processor)

✅ Dynamic header detection (no hardcoded indices) DONE (local processor)

✅ Header row scan (not assumed row 1) DONE (local processor)

Context / tracking

✅ sheet_name tracking per row DONE (local processor)

✅ SHEETS_MODE config (all/first/allowlist/denylist) DONE (local processor)

✅ Per-sheet import logging breakdown DONE (local processor)

Identifier choice (Customer ID / Home ID)

✅ Decision: use home_id = លេខផ្ទះ as customer ID (stable) DONE (decision/requirement is clear)

✅ Code fully updated to always use home_id consistently DONE (local processor)

Zone (Collector/Follower) Handling

✅ Strict first follower: if a duplicate row arrives with a different sheet_name, keep existing zone and log a ZONE_CONFLICT error DONE (local processor)


Process ALL sheets in an Excel file and extract rows reliably using dynamic header detection (Khmer + English variations), without hardcoded column indices. Preserve sheet ownership and output stable customer identifiers.

Current Problems (must fix)

Legacy in-app Excel worker (src/) still processes only first sheet (workbook.SheetNames[0])

Legacy in-app Excel worker still uses hardcoded column indices (breaks when columns shift)

Legacy in-app Excel worker missing sheet_name in extracted rows (lose “belongs to Sros” context)

Legacy in-app Excel worker assumes header row at fixed position

Legacy in-app Excel worker has no sheet selection config (all/first/allowlist/denylist)


Definitions (avoid future confusion)
Identifiers

home_id = លេខផ្ទះ (real-world stable ID for monthly billing) ✅ use this for matching/recurring ARs

customer_uuid = optional internal DB id (generated by system) ❗do NOT treat as home_id

Ownership / Belonging

sheet_name represents owner/collector/zone group (example: sheet "Sros" → rows belong to "Sros")

Date Logic (billing cycle rule)

Excel date = billing cycle reference (e.g., 2025-12-25 means “January cycle”)

due_date = addMonths(excel_date, 1) ✅

invoice_date = now() when AR created from Excel

IMPORTANT: implement date adjustment in code post-processing, not by GPT (models forget).

Step 1: Update Data Models

File: excel-processor-local/src/models/excel-import.ts

export interface ExcelRowData {
  sheet_name: string; // ownership / belongs-to
  source: {
    file: string;
    sheet: string;
    row_index: number; // 1-indexed Excel row
  };

  // identifiers
  home_id: string;          // from "លេខផ្ទះ"
  customer_uuid?: string;   // optional internal id (if exists later)

  // raw fields
  customer_name: string;
  phone?: string;

  amount_raw: string;
  date_raw: string;         // billing cycle reference date (raw from sheet)
  notes?: string;

  raw_data: any;
}


Also add per-sheet summary to import log:

export interface ExcelImportLog {
  // ...
  sheets_processed: Array<{
    sheet_name: string;
    header_row_index: number;
    rows_found: number;
    rows_successful: number;
    rows_failed: number;
    skipped_reason?: string; // e.g. "no header detected"
  }>;
}

Step 2: Add Configuration

File: excel-processor-local/src/config.ts

excel: {
  sheetsMode: process.env.SHEETS_MODE || 'all',  // all|first|allowlist|denylist
  sheetsAllowlist: (process.env.SHEETS_ALLOWLIST || '')
    .split(',').map(s => s.trim()).filter(Boolean),
  sheetsDenylist: (process.env.SHEETS_DENYLIST || '')
    .split(',').map(s => s.trim()).filter(Boolean),

  maxSheetsPerFile: parseInt(process.env.MAX_SHEETS_PER_FILE || '20', 10),
  headerScanRows: parseInt(process.env.HEADER_SCAN_ROWS || '30', 10),

  // header detection quality controls
  minHeadersRequired: parseInt(process.env.MIN_HEADERS_REQUIRED || '3', 10),
}

Step 3: Implement Header Detection Utility (robust)

New file: excel-processor-local/src/utils/header-detector.ts

Requirements

Normalize headers:

trim, lowercase

collapse multiple spaces

remove punctuation like ":" "។" "-" "_"

Support Khmer + English variants

Return null if confidence too low (avoid wrong extraction)

Allow slightly messy headers like លេខផ្ទះ vs លេខ ផ្ទះ

export interface HeaderMapping {
  home_id?: number;        // "លេខផ្ទះ"
  customer_name?: number;  // "ឈ្មោះអតិថិជន"
  phone?: number;          // "លេខទូរសព្ទ"
  billing_date?: number;   // "ថ្ងៃបង់ប្រាក់" (raw, billing reference)
  amount?: number;         // "ប្រាក់ត្រូវបង់"
  installment?: number;
  notes?: number;
}

export function detectHeaders(
  rows: any[][],
  maxScanRows = 30,
  minHeadersRequired = 3
): { headerRowIndex: number; mapping: HeaderMapping; score: number } | null;


Header patterns (expandable):

const HEADER_PATTERNS = {
  home_id: ['លេខផ្ទះ','លេខ ផ្ទះ','house','house id','home id'],
  customer_name: ['ឈ្មោះអតិថិជន','ឈ្មោះ','customer name','name'],
  phone: ['លេខទូរសព្ទអតិថិជន','លេខទូរសព្ទ','phone','tel'],
  billing_date: ['ថ្ងៃបង់ប្រាក់','payment date','date'],
  amount: ['ប្រាក់ត្រូវបង់','ចំនួនទឹកប្រាក់','amount','total'],
  installment: ['លើកទី','installment'],
  notes: ['បរិយាយ','notes','ផ្សេងៗ'],
};


Scoring rule (simple but safe):

score = number of mapped required headers found

required headers: home_id OR customer_name AND amount AND billing_date

if score < minHeadersRequired → return null

Step 4: Rewrite Excel Parser for Multi-Sheet

File: excel-processor-local/src/services/excel-parser.service.ts

Key behavior

Determine which sheets to process (config-driven)

For each sheet:

convert to header:1 matrix

detect headers

extract rows using mapping

stop after 3 consecutive blank rows

always attach sheet_name and source

Must include home_id

A row is considered valid if:

(home_id OR customer_name) AND amount_raw exist

Prefer home_id as primary key (monthly billing)

Important: Don’t skip rows just because customer_name is blank if home_id exists.

Step 5: Date Transformation (do in code, not GPT)

Where: after parsing, before sending to GPT or API

Parse Excel date_raw into a real date (billing_cycle_date)

Compute:

due_date = addMonths(billing_cycle_date, 1)

invoice_date = now()

Edge cases you must handle

Excel dates sometimes come as:

JS Date

serial numbers

formatted strings like 25-12-25, 12/25/2025

Normalize into ISO YYYY-MM-DD in output.

Step 6: Update Import Logging

File: excel-processor-local/src/workers/excel-processor.ts

Track:

header_row_index per sheet (from detector)

rows found vs success/fail

skipped sheet reasons

Step 7: GPT Processing (preserve sheet ownership + ids)

File: excel-processor-local/src/services/gpt-processing.service.ts

Rules

GPT must not invent identifiers.

Input includes:

sheet_name, home_id, row_index, amount_raw, date_raw, notes

Output must echo:

sheet_name, home_id, row_index

Date adjustment happens outside GPT.

Validation error format must include:

file + sheet_name + row_index

Step 8: Testing Plan
Unit tests

header detection:

Khmer variants

shifted columns

header row not at top

missing headers → returns null

sheet filtering:

all/first/allowlist/denylist

date parsing:

string formats

excel serial number

JS Date

Integration tests

Real 20-sheet workbook

Random sheet order

Empty sheets skipped

Different column layouts per sheet

Confirm totals = sum across sheets

Success Criteria

All sheets processed according to config

No hardcoded column indices

Every extracted row includes:

sheet_name, source, home_id (if present)

Date rule applied:

due_date = excel_date + 1 month

invoice_date = now()

Import log shows per-sheet breakdown

Why these changes matter

Prevent “silent wrong JSON” (most dangerous bug)

Make home_id the stable monthly customer key

Preserve “belongs-to Sros” for routing/ownership

Make parsing resilient to messy real-world Khmer Excel
